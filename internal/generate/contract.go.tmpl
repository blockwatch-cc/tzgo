{{- define "entryParamsList" -}}
    {{- range .Params}}{{camel .Name}} {{type .Type}},{{end -}}
{{- end -}}

{{- define "originalSignature" -}}
    {{- $nArgs := len .Params -}}
	{{.Name}}({{range $i, $param := .Params}}{{$param.Name}} {{$param.OriginalType}}{{if lt $i (sub $nArgs 1)}}, {{end}}{{end}})
{{- end -}}

{{- /*gotype: blockwatch.cc/tzgo/internal/generate.Data*/ -}}

// Code generated by tzgen - DO NOT EDIT.
// This file is a binding generated from {{.Contract.Name}} smart contract{{if ne .Address ""}} at address {{.Address}}{{end}}.
// Any manual changes will be lost.

package {{.Package}}

import (
	"context"
	"encoding/json"
	"math/big"
	"time"

	"blockwatch.cc/tzgo/contract"
	"blockwatch.cc/tzgo/contract/bind"
	"blockwatch.cc/tzgo/micheline"
	"blockwatch.cc/tzgo/rpc"
	"blockwatch.cc/tzgo/tezos"
	"github.com/pkg/errors"
)

{{$contract := pascal .Contract.Name}}
{{$r := receiver $contract}}
{{$rc := printf "(%s *%s)" $r $contract}}
{{$rs := printf "(%s *%sSession)" $r $contract}}
{{$rb := printf "(%sBuilder)" $contract}}

{{with .Contract -}}

// {{$contract}} is a generated binding to a Tezos smart contract.
type {{$contract}} struct {
	bind.Contract
	builder {{$contract}}Builder
	rpc bind.RPC
	script *micheline.Script
}

// {{$contract}}Session is a generated binding to a Tezos smart contract, that will
// use Opts for every call.
type {{$contract}}Session struct {
	*{{$contract}}
	Opts *rpc.CallOptions
}

// {{$contract}}Builder is a generated struct that builds micheline.Parameters from
// go types.
type {{$contract}}Builder struct{}

// New{{$contract}} creates a new {{$contract}} handle, bound to the provided address
// with the given rpc.
//
// Returns an error if the contract was not found at the given address.
func New{{$contract}}(ctx context.Context, address tezos.Address, client *rpc.Client) (*{{$contract}}, error) {
	script, err := client.GetContractScript(ctx, address)
	if err != nil {
		return nil, err
	}

	return &{{$contract}}{
		Contract: contract.NewContract(address, client),
		rpc: client,
		script: script,
	}, nil
}

// Session returns a new {{$contract}}Session with the configured rpc.CallOptions.
func {{$rc}} Session(opts *rpc.CallOptions) *{{$contract}}Session {
	return &{{$contract}}Session{ {{- $contract}}: {{$r}}, Opts: opts}
}

// Builder returns the builder struct for this contract.
func {{$rc}} Builder() {{$contract}}Builder {
	return {{$r}}.builder
}

// Storage queries the current storage of the contract.
func {{$rc}} Storage(ctx context.Context) ({{type .Storage}}, error) {
	return {{$r}}.StorageAt(ctx, rpc.Head)
}

// StorageAt queries the contract's storage at the given block.
func {{$rc}} StorageAt(ctx context.Context, block rpc.BlockID) ({{type .Storage}}, error) {
	var storage {{type .Storage}}
	prim, err := {{$r}}.rpc.GetContractStorage(ctx, {{$r}}.Contract.Address(), block)
	if err != nil {
		return storage, errors.Wrap(err, "failed to get storage")
	}
	{{if eq .Storage.MichelineType "struct" -}}
		prim = micheline.NewSeq(prim.UnfoldPairRecursive({{$r}}.script.StorageType())...)
	{{- end}}
	err = bind.UnmarshalPrim(prim, &storage)
	if err != nil {
		return storage, errors.Wrap(err, "failed to unmarshal storage")
	}
	{{- if eq .Storage.MichelineType "struct" -}}
		{{- range .Storage.Fields -}}
			{{- if eq .Type.MichelineType "big_map"}}
				storage.{{pascal .Name}}.SetRPC({{$r}}.rpc)
			{{- end -}}
		{{- end -}}
	{{- end}}
	return storage, nil
}

// StorageFrom decodes micheline prim to contract storage
func {{$rc}} StorageFrom(prim micheline.Prim) ({{type .Storage}}, error) {
	var storage {{type .Storage}}
	{{if eq .Storage.MichelineType "struct" -}}
		prim = micheline.NewSeq(prim.UnfoldPairRecursive({{$r}}.script.StorageType())...)
	{{- end}}
	err := bind.UnmarshalPrim(prim, &storage)
	if err != nil {
		return storage, errors.Wrap(err, "failed to unmarshal storage")
	}
	{{- if eq .Storage.MichelineType "struct" -}}
		{{- range .Storage.Fields -}}
			{{- if eq .Type.MichelineType "big_map"}}
				storage.{{pascal .Name}}.SetRPC({{$r}}.rpc)
			{{- end -}}
		{{- end -}}
	{{- end}}
	return storage, nil
}

func {{$contract}}StorageFrom(prim micheline.Prim) (*UsdtTetherStorage, error) {
    t := {{$contract}}{}
    err := json.Unmarshal([]byte({{$contract}}Micheline), &t.script)
    if err != nil {
        return nil, errors.Wrap(err, "failed to unmarshal contract's script")
    }
    return t.StorageFrom(prim)
}

// Deploy{{$contract}} deploys a {{$contract}} contract by using client and opts, and {{$contract}}Micheline.
//
// Returns the receipt and a handle to the {{$contract}} deployed contract.
func Deploy{{$contract}}(ctx context.Context, opts *rpc.CallOptions, client *rpc.Client, storage {{type .Storage}}) (*rpc.Receipt, *{{$contract}}, error) {
	var script *micheline.Script
	err := json.Unmarshal([]byte({{$contract}}Micheline), &script)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to unmarshal contract's script")
	}

	prim, err := bind.MarshalPrim(storage, false)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to marshal storage")
	}
	script.Storage = prim

	c := contract.NewEmptyContract(client).WithScript(script)
	receipt, err := c.Deploy(ctx, opts)
	if err != nil {
		return nil, nil, errors.Wrap(err, "failed to deploy contract")
	}
	return receipt, &{{$contract}}{Contract: c, rpc: client}, nil
}

// region Entrypoints

{{range .Entrypoints}}

// {{pascal .Name}} makes a call to the `{{.Name}}` contract entry.
//
// {{template "originalSignature" .}}
func {{$rc}} {{pascal .Name}}(ctx context.Context, opts *rpc.CallOptions, {{template "entryParamsList" .}}) (*rpc.Receipt, error) {
	params, err := {{$r}}.builder.{{pascal .Name}}({{range .Params}}{{camel .Name}},{{end}})
	if err != nil {
		return nil, err
	}
	return {{$r}}.Contract.Call(ctx, &contract.TxArgs{Params: params}, opts)
}

// {{pascal .Name}} makes a call to the `{{.Name}}` contract entry.
//
// {{template "originalSignature" .}}
func {{$rs}} {{pascal .Name}}(ctx context.Context, {{template "entryParamsList" .}}) (*rpc.Receipt, error) {
	return {{$r}}.{{$contract}}.{{pascal .Name}}(ctx, {{$r}}.Opts, {{range .Params}}{{camel .Name}},{{end}})
}

// {{pascal .Name}} builds `{{.Name}}` contract entry's parameters.
//
// {{template "originalSignature" .}}
func {{$rb}} {{pascal .Name}}({{template "entryParamsList" .}}) (micheline.Parameters, error) {
	prim, err := bind.MarshalParams(false, {{range .Params}}{{camel .Name}},{{end}})
	if err != nil {
		return micheline.Parameters{}, errors.Wrap(err, "failed to marshal params")
	}
	return micheline.Parameters{Entrypoint: {{print $contract (pascal .Name)}}Entry, Value: prim}, nil
}

{{end}}

// endregion

{{if gt (len .Getters) 0}}

// region Getters

{{range .Getters}}

// {{pascal .Name}} gets the result of the `{{.Name}}` TZIP-4 view.
//
// {{template "originalSignature" .}}
func {{$rc}} {{pascal .Name}}(ctx context.Context, {{template "entryParamsList" .}}) ({{type .ReturnType}}, error) {
	var res {{type .ReturnType}}
	params, err := {{$r}}.builder.{{pascal .Name}}({{range .Params}}{{camel .Name}},{{end}})
	prim, err := {{$r}}.Contract.RunView(ctx, params.Entrypoint, params.Value)
	if err != nil {
		return res, err
	}
	if err = bind.UnmarshalPrim(prim, &res); err != nil {
		return res, errors.Wrap(err, "failed to unmarshal res")
	}
	return res, nil
}

// {{pascal .Name}} builds `{{.Name}}` TZIP-4 view's parameters.
//
// {{template "originalSignature" .}}
func {{$rb}} {{pascal .Name}}({{template "entryParamsList" .}}) (micheline.Parameters, error) {
	prim, err := bind.MarshalParams(false, {{range .Params}}{{camel .Name}},{{end}})
	if err != nil {
		return micheline.Parameters{}, errors.Wrap(err, "failed to marshal params")
	}
	return micheline.Parameters{Entrypoint: {{print $contract (pascal .Name)}}Entry, Value: prim}, nil
}

{{end}}

// endregion

{{- end}}

{{- end}}

{{range .Structs}}

{{$rs := printf "(%s *%s)" $r (pascal .Name)}}
{{$n := len .Fields}}

// {{pascal .Name}} is a generated struct used to interact with {{$contract}} smart contract.
type {{pascal .Name}} struct {
	{{range .Fields}}
		{{pascal .Name}} {{type .Type}}
	{{- end}}
}

{{$path := printf "%sPaths" (pascal .Name)}}
var {{$path}} = {{printf "%#v" .Path }}

// MarshalPrim marshals {{pascal .Name}} into a Prim.
func {{$rs}} MarshalPrim(optimized bool) (micheline.Prim, error) {
	return bind.MarshalParamsPath(optimized, {{$path}}, {{range .Fields}}{{$r}}.{{pascal .Name}},{{end}})
}

// UnmarshalPrim unmarshals a Prim into a {{pascal .Name}}.
func {{$rs}} UnmarshalPrim(prim micheline.Prim) error {
	{{if eq $n 1 -}}
		return bind.UnmarshalPrim(prim, &{{index .Fields 0}})
	{{- else if .Flat -}}
		return bind.UnmarshalPrimPaths(prim, map[string]any{
			{{- range $i, $field := .Fields -}}
				"{{$i}}": &{{$r}}.{{pascal $field.Name}},
			{{- end -}}
		})
	{{- else -}}
		return bind.UnmarshalPrimPaths(prim, map[string]any{
		{{- range $i, $field := .Fields -}}
			"{{pathFromIdx $i $n}}": &{{$r}}.{{pascal $field.Name}},
		{{- end -}}
		})
	{{- end}}
}

{{end}}

// {{$contract}} entry names
const (
	{{- range .Contract.Entrypoints}}
		{{print $contract (pascal .Name)}}Entry = "{{.Name}}"
	{{- end -}}
	{{- range .Contract.Getters}}
		{{print $contract (pascal .Name)}}Entry = "{{.Name}}"
	{{- end -}}
)

const {{$contract}}Micheline = `{{.Contract.Micheline}}`

var (
	_ = big.NewInt
	_ = micheline.NewPrim
	_ = bind.MarshalParams
	_ = time.Now
)
